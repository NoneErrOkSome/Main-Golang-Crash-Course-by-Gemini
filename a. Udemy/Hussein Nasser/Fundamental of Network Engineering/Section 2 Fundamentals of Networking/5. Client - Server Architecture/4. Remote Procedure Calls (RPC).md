

## üîπ **Part 4: Remote Procedure Calls (RPC)**

---

### üìû **What Is a Procedure Call? (Local First)**

Let‚Äôs start simple.

When you call a function in your code, like:

```js
getUserData()
```

That‚Äôs a **procedure call** ‚Äî your program is jumping to another section of code, doing some work, and returning the result. It all happens **inside the same machine**.

But what if the code you want to call is **on another machine**?  
What if `getUserData()` lives on a server halfway across the world?

That‚Äôs where **Remote Procedure Call (RPC)** comes in.

---

### üåê **What Is a Remote Procedure Call?**

A **Remote Procedure Call** lets you call a function that exists on another machine ‚Äî like it‚Äôs local.

Behind the scenes, it:

- Sends a **network request** to a server.
    
- That server **executes the function**.
    
- The result is **sent back** to your machine.
    

From your code‚Äôs perspective, it‚Äôs as if you're just calling a normal function ‚Äî but it's **actually happening remotely**.

That‚Äôs the magic of RPC.

---

### üèóÔ∏è **How It Fits Into Client-Server**

RPC is a **natural match** for the client-server model:

- The **client** sends a request that says: ‚ÄúRun this function with these inputs.‚Äù
    
- The **server** runs the function and sends back the result.
    

So instead of the client doing everything itself, it just **asks the server to do something** on its behalf ‚Äî like:

```plaintext
"Hey server, calculate this report for me and send it back."
```

---

### üß™ **Early RPC Was the Wild West**

In the early days:

- There was **no standard way** to do RPC.
    
- People would just **send raw data** over a wire and hope the server understood.
    
- As long as the **two sides agreed** on the format, it worked ‚Äî but it wasn‚Äôt portable, and it wasn‚Äôt safe.
    

Imagine mailing a letter in your own language and hoping the receiver speaks it too.  
That‚Äôs what early RPC was like.

---

### üß± **Then Came Standards**

People started realizing:

> ‚ÄúWe need a **common format** and **rules** for how to do this properly.‚Äù

That led to:

- **SOAP** (a heavy XML-based protocol)
    
- **JSON-RPC** (a lighter format using JSON)
    
- And eventually **gRPC**, developed by Google
    

---

### üöÄ **gRPC: The Modern RPC Protocol**

**gRPC** is a modern, fast, and efficient RPC system created by Google.

It builds on the **classic idea** of RPC, but adds:

- **Standardized interfaces** using Protocol Buffers (protobuf)
    
- **Streaming** support (send/receive in real time)
    
- Strong **type checking**
    
- **Cross-language** communication (e.g., Go server ‚Üî Python client)
    

So now we can say:

> ‚ÄúLet‚Äôs build two separate services, written in different languages, and they can still talk to each other ‚Äî reliably.‚Äù

That‚Äôs huge for **microservices**, **cloud apps**, and distributed systems.

---

### üí° **The Key Insight**

> ‚ÄúRPC is just a way to ask another machine to run a function for you.‚Äù

It fits perfectly with client-server:

- The **client** does not need to know _how_ the task is done.
    
- The **server** just exposes _what_ it can do.
    

RPC **abstracts the network** so the client can act like it‚Äôs calling a local function ‚Äî but it‚Äôs really reaching across the internet.

---

### ‚öñÔ∏è **RPC vs REST (Quick Thought)**

While not mentioned directly, it‚Äôs useful to know:

|Feature|REST|RPC (e.g., gRPC)|
|---|---|---|
|Format|HTTP + JSON|HTTP/2 + Protocol Buffers|
|Style|Resource-based (nouns)|Action-based (verbs/functions)|
|Simplicity|Human-friendly|Code-efficient, fast|
|Usage|Web APIs|Microservices, internal APIs|

---

### üîö Summary

- RPC allows programs to **call functions on remote machines**, like calling a local function.
    
- It was originally **unstandardized** and fragile.
    
- Standards like **gRPC** have made RPC powerful and universal.
    
- RPC is the **backbone of communication** in client-server and microservice systems.
    
- It enables **clean separation of responsibility**, where clients ask, and servers deliver.
    

---

Would you like to continue with **Part 5: Benefits of Client-Server Architecture** next?